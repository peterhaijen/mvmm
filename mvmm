#!/usr/bin/perl

use strict;
use warnings;
use Time::HiRes qw(usleep time);
use Time::Local;
use IO::Socket::INET;
use POSIX qw(strftime WNOHANG);
use AppConfig;
use Sys::Syslog qw(:standard :macros);
use POSIX qw(floor);
use feature 'state';
use File::Pid;
use IO::Socket::UNIX;
use JSON;
#use Data::Dump;

my %children;
my $maintenance_mode = 0;
my %name;

my $config_dir = '/etc/pve/mvmm';
my $global_config_file = "$config_dir/mvmm.conf";
my $config = AppConfig->new({ CASE => 1, ERROR => sub { printf STDERR "Ignoring invalid argument: " . shift . "\n" } });
$config->define("disabled_log_interval", { DEFAULT => 25200,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("check_interval",        { DEFAULT =>    60,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("fail_interval",         { DEFAULT =>    15,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("fail_threshold",        { DEFAULT =>    30,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("wait_interval",         { DEFAULT =>    15,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("boot_time",             { DEFAULT =>    60,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("log_interval",          { DEFAULT =>   900,   ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("portsall",              {                     ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("portsany",              {                     ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("enabled",               { DEFAULT => 'false', ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("name",                  {                     ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("ip",                    {                     ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("restart_at",            {                     ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("restart_after",         {                     ARGCOUNT => AppConfig::ARGCOUNT_ONE });
$config->define("nofork|n!",             { DEFAULT => 0 });
$config->define("usr1|1!",               { DEFAULT => 0 });
$config->define("usr2|2!",               { DEFAULT => 0 });
$config->define("pidfile!",              { DEFAULT => '/tmp/mvmm.pid' });

$config->file($global_config_file) if -f $global_config_file;
$config->args() or die "Invalid arguments";

my $pidfile = File::Pid->new({ file => $config->pidfile });

if ( $config->usr1 || $config->usr2 ) {
    # We want to send a signal to an existing process
    if ( my $pid = $pidfile->running ) {
        print "Sending signal to daemon process $pid\n";
        my $n = kill $config->usr1 ? 'USR1' : 'USR2', $pid;
        warn "Failed to send signal to $pid: $!" unless $n;
        exit( $n > 0 );
    } else {
        print "No server process running, aborting.\n";
        exit(10);
    }
    # Not reached
}

if ( $< || $> ) {
    # Not running as root
    print "Not running as root, aborting\n";
    exit(10);
}

openlog('mvmm', 'pid', 'user');

if ( my $pid = $pidfile->running ) {
    # A process is already running
    syslog('info', "mvmm supervisor already running with pid $pid, aborting");
    exit(10);
}

# Create a PID file
$pidfile->remove;
my $pid = $pidfile->write;

END {
    if ( defined $pid && $pid == $$ ) {
        # parent process should remove pid file
        $pidfile->remove;
    }
}

syslog('info', "mvmm supervisor started.");

$SIG{TERM} = \&graceful_exit;
$SIG{INT}  = \&graceful_exit;

my $last_log = 0;

$SIG{USR1} = sub { 
    if ( $pid == $$ ) {
        # Parent

        # Show maintenance mode
        syslog('info', "Supervisor - maintenance mode: $maintenance_mode");

        # Show number of monitored VMs
        my $count = scalar keys %children;
        syslog('info', "Supervisor - monitoring ${count} VMs");

        # Forward signal to all children for added info
        foreach my $pid (keys %children) { kill 'USR1', $pid; }

        # And reset last_log time to show more info
        $last_log = 0;
    } else {
        # A monitoring child
        $last_log = 0;
    }
};

$SIG{USR2} = sub {
    $maintenance_mode = 1 - $maintenance_mode;
    if ( $pid == $$ ) {
        # This is the parent process
        syslog('info', "Supervisor maintenance mode toggled to $maintenance_mode");
        foreach my $pid (keys %children) { kill 'USR2', $pid; }
    }
};

sub logmsg {
    my ($tag, $level, $msg) = @_;
    openlog($tag, 'pid', 'user');
    syslog($level, $msg);
    closelog();
}

sub graceful_exit {
    if ( $pid == $$ ) {
        # Parent
        syslog('info', "Supervisor about to exit, killing children.");
        kill 'TERM', $_ for keys %children;
        sleep(1);
        syslog('info', "Supervisor exiting.");
        closelog();
        exit(0);
    } else {
        # A child process
        exit(0);
    }
}

sub supervise_children {
    while (1) {
        foreach my $pid (keys %children) {
            my $dead = waitpid($pid, WNOHANG);
            if ($dead > 0) {
                my $vmid = delete $children{$pid};
            }
        }
        discover_new_vms();
        sleep(10);
    }
}

sub discover_new_vms {

    state %vms_not_here;
    my %status;

    opendir(my $dh, $config_dir) or die "Cannot open $config_dir: $!";
    my @vm_confs = grep { /^\d+\.conf$/ } readdir($dh);
    closedir($dh);

    open QMLIST, "qm list|" or die "Cannot list qemu VMs: $!";
    while (<QMLIST>) {
        if ( /^\s+(\d+)\s+([^ ]+)\s+([^ ]+)/ ) {
            my $vmid = $1;
            $name{$vmid} = $2;
            $status{$vmid} = $3;
        }
    }
    close QMLIST;

    if ( time() - $last_log > $config->log_interval ) {
        %vms_not_here = ();
        $last_log = time();
    }

    foreach my $file (@vm_confs) {
        (my $vmid = $file) =~ s/\.conf$//;
        next if grep { $_ eq $vmid } values %children;
        if (! defined $status{$vmid}) {
            unless ( $vms_not_here{$vmid} ) {
                syslog('info', "VM $vmid does not exist on this server.");
                $vms_not_here{$vmid} = 1;
            }
        } elsif ($status{$vmid} =~ /running/) {
            syslog('info', "[$name{$vmid}] VM $vmid is running, starting monitor.");
            if ( $config->nofork ) {
                monitor_vm($vmid); # For testing without a child process
            } else {
                start_monitor_for_vmid($vmid);
            }
            delete $vms_not_here{$vmid};
        } else {
            unless ( $vms_not_here{$vmid} ) {
                syslog('notice', "[$name{$vmid}] VM $vmid: $status{$vmid}, not monitoring");
                $vms_not_here{$vmid} = 1;
            }
        }
    }
}

sub start_monitor_for_vmid {
    my ($vmid) = @_;
    my $pid = fork();
    if (!defined $pid) {
        die "Cannot fork: $!";
    } elsif ($pid == 0) {
        monitor_vm($vmid);
        exit(0);
    } else {
        $children{$pid} = $vmid;
    }
}

sub monitor_vm {
    my ($vmid) = @_;
    my $vm_conf_file = "$config_dir/$vmid.conf";
    $config->file($vm_conf_file) if -f $vm_conf_file;

    my $name = $name{$vmid};
    my $ip = $config->get("ip");
    my @portsall = split(' ', $config->get("portsall") // '');
    my @portsany = split(' ', $config->get("portsany") // '');
    my $enabled = lc($config->get("enabled") // 'true') eq 'true';
    my $check_interval = $config->get("check_interval");
    my $fail_interval = $config->get("fail_interval");
    my $fail_threshold = $config->get("fail_threshold");
    my $wait_interval = $config->get("wait_interval");
    my $log_interval = $config->get("log_interval");
    my $boot_time = $config->get("boot_time");

    my $restart_at = $config->get("restart_at");
    my $restart_after = $config->get("restart_after");

    $last_log = time();
    my $booting = 1;

    if (!$enabled) {
        disabled_loop($vmid, $name, $config->get("disabled_log_interval"));
        return;
    }

    my $last_scheduled_restart = 0;
    my $firsterror;
    my $restarted = time();

    while (1) {
        my $now = time();

        if (is_healthy($ip, \@portsall, \@portsany)) {
            if ( $firsterror ) {
                my $elapsed = floor($now-$firsterror+0.5);
                syslog('info', "[$name] Online after ${elapsed}s.");
            }
            $firsterror = $booting = undef;

            if ($restart_at) {
                my ($hr, $min) = $restart_at =~ /^(\d\d):(\d\d)$/;
                if (defined $hr && defined $min) {
                    my @lt = localtime($now);
                    my $today_restart = timelocal(0, $min, $hr, @lt[3,4,5]);
                    if ($now >= $today_restart && $last_scheduled_restart < $today_restart) {
                        syslog('notice', "[$name] Scheduled restart at $restart_at triggered.");
                        reboot_vm($vmid, $name, $wait_interval);
                        $last_scheduled_restart = $restarted = $now;
                        $booting = 1;
                    }
                }
            }

            if ($restart_after) {
                if (($now - $restarted) >= $restart_after) {
                    syslog('notice', "[$name] Restarting - $restart_after seconds have elapsed.");
                    reboot_vm($vmid, $name, $wait_interval);
                    $restarted = $now;
                    $booting = 1;
                }
            }

        } else {

            # VM is not healthy anymore. Perhaps it's not running anymore?
            my $vm_status = get_status($vmid);

            if ($vm_status !~ /running/) {
                syslog('info', "[$name] VMID $vmid is no longer available or not running. Exiting monitor.");
                return;
            }

            # Status is 'running' but it's not healthy

            $firsterror //= $now;
            my $after_seconds;
            my $msg;

            if ( $maintenance_mode ) {
                $after_seconds = 0;
                $msg = "[$name] Failed health check; maintenance mode active, no reboot will occur.";
            } elsif ( $booting ) {
                $after_seconds = $boot_time;
                $msg = "[$name] Failed health check; reboot at " . localtime($firsterror + $after_seconds);
            } else {
                $after_seconds = $fail_threshold;
                $msg = "[$name] Failed health check; reboot at " . localtime($firsterror + $after_seconds);
            }

            if ( ($now - $last_log) >= $log_interval || $firsterror == $now ) {
                syslog('warning', $msg);
                $last_log = $now;
            }

            if ($after_seconds && ($now - $firsterror) >= $after_seconds) {
                syslog('err', "[$name] VM unhealthy for $after_seconds seconds, rebooting now!");
                reboot_vm($vmid, $name, $wait_interval);
                $restarted = $now;
                $firsterror = undef;
                $booting = 1;
            }
        }

        if (!$firsterror && (($now - $last_log) >= $log_interval)) {
            my $datetime = localtime($restarted);
            syslog('info', "[$name] Monitoring - online since: ${datetime}");

            if ($restart_at) {
                syslog('info', "[$name] Restarting at ${restart_at}");
            }

            if ($restart_after) {
                my $at = localtime($restarted + $restart_after);
                syslog('info', "[$name] Restarting at ${at}");
            }

            $last_log = $now;
        }

        sleep($check_interval);
    }
}

sub disabled_loop {
    my ($vmid, $name, $disabled_log_interval) = @_;
    my $last_log = 0;
    while (1) {
        my $now = time();
        if ($now - $last_log >= $disabled_log_interval) {
            logmsg($name, 'info', "Section [$vmid] ($name) is disabled. No monitoring performed.");
            $last_log = $now;
        }

        sleep(15);

        my $vm_status = get_status($vmid);

        if ($vm_status !~ /running/) {
            syslog('info', "[$name] VMID $vmid is no longer available or not running. Exiting monitor.");
            return;
        }
    }
}

sub is_healthy {
    my ($ip, $portsall, $portsany) = @_;
    foreach my $port (@$portsall) {
        return 0 unless port_open($ip, $port);
    }
    if (@$portsany) {
        foreach my $port (@$portsany) {
            return 1 if port_open($ip, $port);
        }
        return 0;
    }
    return 1;
}

sub get_status {
    my ($vmid) = @_;
    #my $status = `qm status $vmid 2>&1`; chop($status);

    my $socket_path = "/run/qemu-server/$vmid.qmp";

    my $status = "stopped";

    if ( my $sock = IO::Socket::UNIX->new(
                            Type => SOCK_STREAM(),
                            Peer => $socket_path) ) {

        # Read the QMP greeting
        my $greeting = <$sock>;
        # print "QMP Greeting: $greeting\n";

        # Enable capabilities
        print $sock encode_json({ execute => 'qmp_capabilities' }) . "\n";
        my $response = <$sock>;
        #print "Capabilities Response: $response\n";

        # Query VM status
        print $sock encode_json({ execute => 'query-status' }) . "\n";
        my $json_response = <$sock>;

        $sock->close();

        # Decode the JSON response
        my $decoded = decode_json($json_response);

        # Access the 'status' field
        $status = $decoded->{return}->{status};
    }

    # syslog('debug', "VM $vmid: status = $status");

    return $status;
}

sub port_open {
    my ($ip, $port) = @_;
    my $sock = IO::Socket::INET->new(PeerAddr => $ip, PeerPort => $port, Timeout => 1);
    return $sock ? 1 : 0;
}

sub reboot_vm {
    my ($vmid, $name, $wait) = @_;
    system("qm shutdown $vmid");

    my $elapsed = 0;
    while ($elapsed < $wait) {
        my $status = get_status($vmid);
        if ($status =~ /stopped/) {
            last;
        }
        sleep(1);
        $elapsed++;
    }

    my $final_status = get_status($vmid);
    unless ($final_status =~ /stopped/) {
        system("qm stop $vmid");
        my $elapsed_stop = 0;
        while ($elapsed_stop < $wait) {
            my $check_status = get_status($vmid);
            last if ($check_status =~ /stopped/);
            sleep(1);
            $elapsed_stop++;
        }
    }

    system("qm start $vmid");
}

supervise_children();
